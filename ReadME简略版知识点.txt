1.基本类型
1.1 ts的基本数据类型
boolean布尔类型
number浮点型
string字符串类型 
array数组类型 
元组类型(指定了数据个数和类型的数组)
enum枚举类型
any类型
void类型(用来表示函数没有返回)
object类型
undefined类型和null类型(ts配置文件关闭严格模式就是所有类型的子类型,可以通过数据类型判断)

1.2 联合类型
(类型1|类型2|...)，用来指定多种数据类型

1.3 类型断言
告诉编译器，我知道我自己是什么类型，也知道自己在干什么
语法：
    方式一:(<类型>值)
    方式二:(值 as 类型)， tsx中只能用这种方式

1.4 类型推断
ts 会在没有明确的指定类型的时候推测出一个类型
情况1：定义变量时赋值了，推断为对应的类型,后面修改也需要保持对应的类型同意
情况2：定义变量时没有赋值，推断为any类型

2.接口
接口是对象的状态(属性)和行为(方法)的抽象(描述)。
就是接口定义了一个数据类型，里面的内容有限制。
接口是一种类型，一种规范，是一种规则，是一种能力，是一种约束。

2.1 可选属性
可选属性:?  放到属性值之后，表示该属性可传可不传

2.2 只读属性
readonly 作为修饰词放到属性之前

2.3 函数类型接口
默认的接口是定义数据类型，函数类型接口就是定义函数的传入的参数和返回内容。

2.4 类 类型
类的类型，类的类型可以通过接口来实现
-> 接口可以定义默认属性和方法，类可以通过implements来实现一个或多个接口约束的属性和方法
-> 接口之间也可以用extends来继承属性方法
-> 如果是做了代码分割，class可以直接implements多个接口来实现对应方法，也可以用一个接口extend需要的多个接口内容，再让class去实现

3.类型
可以理解为模板，通过模板可以实例化对象，面向对象的编程思想。

3.1类的继承
继承:类与类之间的关系，需要使用extends关键字
子类中可以调用父类中的构造函数，使用的是super关键字(包括调用父类中的实例方法，也可以使用super)
子类当中可以重写父类中的方法

3.2类的多态
父类型的引用指向子类型的对象，不同类型的对象针对相同的方法，产生了不同的行为。
子类继承父类，在对象判断上可以被判断为父类的同类，但是内置方法属性上被改写，调用会有不同的结果。
--> 子类继承父类的属性方法后,修改了部分属性内容，在类型判断是被视为与父类同类。
--> 从指定传入参数是父类，但是你传入继承后的子类也能行的通这点看，子类被当成了父类，看起来是父类的不同形态，也就是多态。o(╯□╰)o

3.3类的修饰符
修饰符(类中的成员的修饰符):主要是描述类中的成员(属性，构造函数，方法)的可访问性
类中的成员都有自己的默认的访问修饰符,public
    public修饰符，类中成员默认的修饰符，代表的是公共的，任何位置都可以访问类中的成员
    private修改符，只能类内部可以访问
    protected修饰符，类内部和子类可以访问

3.4类中的 readonly 修饰符 --> 保证属性只读，根据参数自动添加属性
首先是一个关键字，对类中的属性成员进行修饰，修饰后该属性成员，就不能在外部被随意修改
构造函数中，可以对只读的属性成员的数据进行修改
如果构造函数中没有任何的参数，类中的属性成员此时已经使用readonly修饰了，那么外部也是不能对这个属性值进行更改的
构造函数中的参数可以使用readonly惊喜修饰，一旦修饰了，那么该类中就有了这个只读的成员属性了，外部可以访问，但是不能修改
构造函数的参数可以使用public,private和protected进行修饰，无论是哪个进行修饰，该类中都会自动添加这个一个属性成员
--> readonly可以修饰初始属性，被修饰的属性可以在构造器中被修改
--> 构造器传入的参数如果有用readonly修饰的变量a，那么这个类就自动添加了一个只能读取的a属性

3.5类中的存取器
让我们可以有效的控制对 对象中的成员的访问，通过getters和setters来进行操作。

3.6类中的静态属性(静态成员) --> 保证某些属性方法被非实例化调用
静态成员：在类中农通过static修饰的属性或方法，那么就是静态的属性及静态的方法，也称之为静态成员
静态成员在使用的时候是通过类名.XXX的这种语法来调用的
静态成员不能通过类的实例化然后调用对应的属性方法
static可以用来修饰类中的属性和方法中，但是不能用来修饰constructor
--> 类中的静态属性只能被添加在属性和方法上，但是不能用在构造器上，用来现在对应的属性方法只能通过类.xxx来获取调用，杜绝实例化后被调用

3.7抽象类(abstract 类) --> 限定属性方法只有被继承后才能调用
包含抽象方法(抽象方法一般没有任何的具体内容的实现)，也可以包含实例方法，抽象类是不能被实例化的，为了让子类进行实例化及实现内部的抽象方法。
--> 抽先类是用abstract修饰的类，不能被实例化，要调用内部的属性方法，可以用子类继承后再调用。

4.函数
封装了一些重复重用的代码，在需要的时候直接调用即可。

4.1函数类型
用来定义函数的参数类型和返回的值的类型

4.2可选参数和默认参数
可选参数:函数在声明的时候，内部的参数后使用了？进行修饰，那么久表示参数可以传入也可以不用传入
默认参数:函数在声明的时候，内部的参数有自己的默认值a:string='默认值'，此时的这个参数就可以叫默认参数

4.3剩余参数(rest参数)
剩余参数是放在函数声时所有参数的最后集合，打印出来为数组形式。

4.4函数重载 --> 函数根据不同参数，进行不同的逻辑处理
函数名字相同，函数的参数及个数不同。
注意在重载函数声明中不需要实现内容，只声明函数名，函数参数类型，函数返回值类型即可。

5.泛型
指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。
--> 泛型的目的是为了使用时保持数据类型的统一，方便处理逻辑。

5.1泛型函数 --> 使用了泛型的函数
使用泛型来充当传入值的类型，注意泛型的定义位置为： function 函数名 <泛型名1, 泛型名2...>(参数1:泛型名1,参数2:泛型名2...){..}
--> 其实也可以用联合类型+类型断言的方式来实现相关的功能，但是比较繁琐。

5.2多个泛型参数的函数
函数中有多个泛型的参数 --> 使用了多个泛型参数的函数

5.3泛型接口 --> 使用了泛型的接口
在定义接口时，为接口中的属性或方法定义泛型类型，在使用接口时，再指定具体的泛型类型。
--> 接口定义时使用了泛型，在实现使用该接口时需要把泛型的数据结构传入

5.4泛型类 --> 使用了泛型的类
在定义类时，为类中的属性或方法定义泛型类型 在创建泛型类的实例时，再指定特定的泛型类型。
--> 定义类时使用了泛型，调用该类需要给泛型指定对应的数据类型

5.5泛型约束
由于泛型是灵活的，是在使用是才传入数据类型的，但是针对某些业务需求，可能需要泛型具备特定的属性，我们可以通过extends继承的方式给泛型添加必要的属性，这个行为就叫泛型约束。
--> 用泛型继承接口的方式来给泛型添加特定属性方法，约束泛型

6.其他相关
6.1ts声明文件可配置成对应的 xxx.d.ts文件，会被自动扫描使用。
6.2ts使用三方库可以安装对应的配置文件 npm install @types/三方库名，记得先从npm上查看相关包
6.3内置对象
```
  // /* 1. ECMAScript 的内置对象, 注意开头字母大小写 */
  // let b: Boolean = new Boolean(1)
  // let n: Number = new Number(true)
  // let s: String = new String('abc')
  // let d: Date = new Date()
  // let r: RegExp = /^1/
  // let e: Error = new Error('error message')
  // // b = true
  // console.log(b)  //  对象身上才有原型 prototype

  // BOM 和 DOM 的内置对象
  // BOM:Window
  // DOM:Document HTMLElement DocumentFragment Event NodeList
  // TS中可以直接使用BOM和DOM

  const div: HTMLElement = document.getElementById('test')
  const divs: NodeList = document.querySelectorAll('div')
  document.addEventListener('click', (event: MouseEvent) => {
    console.dir(event.target)
  })
  const fragment: DocumentFragment = document.createDocumentFragment()
```
